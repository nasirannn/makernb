import { NextRequest, NextResponse } from 'next/server';

import { updateMusicGenerationByTaskId } from '@/lib/music-db';
import { createGenerationError } from '@/lib/generation-errors-db';
import { addUserCredits } from '@/lib/user-db';
import { downloadFromUrl, uploadAudioFile } from '@/lib/r2-storage';
import { query } from '@/lib/db-query-builder';

// Cache for processed tasks to handle idempotency
const processedTasks = new Set<string>();

/**
 * ÈáçËØïÊï∞ÊçÆÂ∫ìÊìç‰ΩúÁöÑËæÖÂä©ÂáΩÊï∞
 * @param operation Ë¶ÅÊâßË°åÁöÑÊï∞ÊçÆÂ∫ìÊìç‰Ωú
 * @param maxRetries ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞
 * @param callbackId ÂõûË∞ÉIDÁî®‰∫éÊó•Âøó
 * @param operationName Êìç‰ΩúÂêçÁß∞Áî®‰∫éÊó•Âøó
 */
async function retryDatabaseOperation(
  operation: () => Promise<void>,
  maxRetries: number,
  callbackId: string,
  operationName: string
): Promise<void> {
  let lastError: Error | null = null;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      await operation();
      if (attempt > 1) {
        console.log(`[CALLBACK-${callbackId}] ${operationName} succeeded on attempt ${attempt}/${maxRetries}`);
      }
      return; // ÊàêÂäüÔºåÈÄÄÂá∫
    } catch (error) {
      lastError = error as Error;
      console.error(`[CALLBACK-${callbackId}] ${operationName} failed on attempt ${attempt}/${maxRetries}:`, error);
      
      if (attempt < maxRetries) {
        // ÊåáÊï∞ÈÄÄÈÅøÔºö1s, 2s, 4s, 8s, 16s
        const delayMs = Math.min(1000 * Math.pow(2, attempt - 1), 16000);
        console.log(`[CALLBACK-${callbackId}] Retrying ${operationName} in ${delayMs}ms...`);
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
    }
  }
  
  // ÊâÄÊúâÈáçËØïÈÉΩÂ§±Ë¥•‰∫Ü
  console.error(`[CALLBACK-${callbackId}] ${operationName} failed after ${maxRetries} attempts`);
  throw new Error(`Database operation failed after ${maxRetries} attempts: ${lastError?.message || 'Unknown error'}`);
}

// Handle Suno API callbacks
export async function POST(request: NextRequest) {
  const startTime = Date.now();
  const callbackId = `callback_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

  console.log(`[CALLBACK-${callbackId}] Suno callback received at ${new Date().toISOString()}`);

  try {
    // 1. Fast response - must return response within 15 seconds
    const callbackData = await request.json();
    console.log(`[CALLBACK-${callbackId}] Callback data parsed:`, {
      code: callbackData.code,
      msg: callbackData.msg,
      taskId: callbackData.data?.task_id,
      callbackType: callbackData.data?.callbackType,
      hasData: !!callbackData.data?.data,
      dataLength: callbackData.data?.data?.length || 0
    });


    // 2. Verify callback source legitimacy (optional - implement as needed)
    // const isValidSource = await verifyCallbackSource(request);
    // if (!isValidSource) {
    //   return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    // }

    const { code, msg, data } = callbackData;
    const taskId = data?.task_id;

    console.log(`[CALLBACK-${callbackId}] Processing callback for taskId: ${taskId}, code: ${code}`);

    // 3. Idempotency handling - avoid duplicate processing of same callback
    // ‰ΩøÁî® callbackType Êù•Âå∫ÂàÜ‰∏çÂêåÁöÑÂõûË∞ÉÁ±ªÂûãÔºåÈÅøÂÖçÁõ∏Âêå code ÁöÑÂÜ≤Á™Å
    const callbackType = data?.callbackType;
    const taskKey = `${taskId}_${callbackType || 'unknown'}_${code}`;
    console.log(`[CALLBACK-${callbackId}] Checking idempotency with taskKey: ${taskKey}`);

    if (processedTasks.has(taskKey)) {
      console.log(`[CALLBACK-${callbackId}] Callback already processed, returning early`);
      return NextResponse.json({
        success: true,
        message: 'Already processed',
        taskId: taskId,
        callbackType: callbackType,
        processedAt: new Date().toISOString()
      });
    }

    // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ§ÑÁêÜËøáÊàêÂäüÁöÑÂõûË∞ÉÔºàÂè™ÊúâÂΩìÊâÄÊúâÈü≥È¢ëÈÉΩÊúâURLÊó∂ÊâçÊ†áËÆ∞‰∏∫ÂÆåÊàêÔºâ
    if (code === 200 && data?.data) {
      const tracks = data.data;
      const allAudioReady = tracks.every((track: any) =>
        track.audio_url && track.audio_url.trim() !== ''
      );

      console.log(`[CALLBACK-${callbackId}] Audio readiness check:`, {
        trackCount: tracks.length,
        allAudioReady,
        trackAudioStatus: tracks.map((t: any, i: number) => ({
          trackIndex: i,
          hasAudioUrl: !!t.audio_url,
          audioUrl: t.audio_url?.substring(0, 50) + '...'
        }))
      });

      if (allAudioReady && processedTasks.has(`${taskId}_completed`)) {
        console.log(`[CALLBACK-${callbackId}] Complete callback already processed`);
        return NextResponse.json({
          success: true,
          message: 'Already completed',
          taskId: taskId,
          processedAt: new Date().toISOString()
        });
      }
    }

    // Mark as processed
    processedTasks.add(taskKey);
    console.log(`[CALLBACK-${callbackId}] Marked taskKey as processed: ${taskKey}`);

    // 4. Return success response immediately to avoid blocking (Á¨¶ÂêàÂÆòÊñπÁ§∫‰æãÊ†ºÂºè)
    const response = NextResponse.json({
      status: 'received'
    });

    // Ê∑ªÂä†CORSÂ§¥ÊîØÊåÅngrok
    response.headers.set('Access-Control-Allow-Origin', '*');
    response.headers.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
    response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');

    // 6. Process complex logic asynchronously to avoid blocking callback response
    console.log(`[CALLBACK-${callbackId}] Scheduling async processing for taskId: ${taskId}`);
    setImmediate(() => {
      processCallbackAsync(callbackData, callbackId);
    });

    // Log processing time to ensure it's within 15 seconds
    const processingTime = Date.now() - startTime;
    console.log(`[CALLBACK-${callbackId}] Response sent in ${processingTime}ms`);

    return response;

  } catch (error) {
    console.error(`[CALLBACK-${callbackId}] Callback processing error:`, error);

    // Return quick response even on error
    const errorResponse = NextResponse.json(
      {
        error: 'Internal server error',
        success: false,
        processedAt: new Date().toISOString()
      },
      { status: 500 }
    );

    // Ê∑ªÂä†CORSÂ§¥ÊîØÊåÅngrok
    errorResponse.headers.set('Access-Control-Allow-Origin', '*');
    errorResponse.headers.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
    errorResponse.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    return errorResponse;
  }
}

// Ê∑ªÂä†OPTIONSÊñπÊ≥ïÊîØÊåÅCORSÈ¢ÑÊ£ÄËØ∑Ê±Ç
export async function OPTIONS(request: NextRequest) {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}

/**
 * Â§ÑÁêÜÈü≥‰πêÁîüÊàêÂõûË∞ÉÁöÑÊ†∏ÂøÉÂáΩÊï∞
 * ÂäüËÉΩÔºöÊé•Êî∂KIE AIÁöÑÂõûË∞ÉÈÄöÁü•ÔºåÂ§ÑÁêÜ‰∏çÂêåÁ±ªÂûãÁöÑÂõûË∞ÉÔºàtext/first/completeÔºâÔºå
 * Â≠òÂÇ®Êï∞ÊçÆÂà∞Êï∞ÊçÆÂ∫ìÂíåR2
 */
async function processCallbackAsync(callbackData: any, callbackId: string) {
  const asyncStartTime = Date.now();
  console.log(`[CALLBACK-${callbackId}] Starting async processing at ${new Date().toISOString()}`);

  try {
    // 1. Ëß£ÊûêÂõûË∞ÉÊï∞ÊçÆ
    const { code, data } = callbackData;
    const taskId = data?.task_id; //Èü≥‰πêÁîüÊàê‰ªªÂä°ID

    console.log(`[CALLBACK-${callbackId}] Parsed callback data:`, {
      code,
      taskId,
      callbackType: data?.callbackType,
      hasData: !!data?.data
    });


    // 2. ËØÜÂà´ÂõûË∞ÉÁ±ªÂûãÂπ∂Â§ÑÁêÜ
    let callbackType = data?.callbackType;
    console.log(`[CALLBACK-${callbackId}] Processing callbackType: ${callbackType}`);

    if (code === 200 && data?.data) {
      // Èü≥‰πêÊï∞ÊçÆÁõ¥Êé•Âú® data.data Êï∞ÁªÑ‰∏≠
      const tracks = data.data;
      console.log(`[CALLBACK-${callbackId}] Processing ${tracks.length} tracks for code 200`);

      // 4. Ê†πÊçÆ‰∏çÂêåÁöÑÂõûË∞ÉÁ±ªÂûãÂ§ÑÁêÜ
      if (callbackType === 'text') {
        console.log(`[CALLBACK-${callbackId}] Processing TEXT callback`);

        // üéØ textÂõûË∞ÉÊó∂ÂºÄÂßãÂ∞ÅÈù¢ÁîüÊàê
        // ‰ΩøÁî®Ê†áËÆ∞ÈÅøÂÖçÈáçÂ§çË∞ÉÁî®Â∞ÅÈù¢ÁîüÊàê
        const coverTaskKey = `${taskId}_cover_started`;
        if (!processedTasks.has(coverTaskKey)) {
          console.log(`[CALLBACK-${callbackId}] Starting cover generation for taskId: ${taskId}`);
          processedTasks.add(coverTaskKey);

          // ÂºÇÊ≠•ÂºÄÂßãÂ∞ÅÈù¢ÁîüÊàêÔºå‰∏çÈòªÂ°ûÂõûË∞ÉÂ§ÑÁêÜ
          setImmediate(async () => {
            try {
              console.log(`[CALLBACK-${callbackId}] Initiating cover generation for taskId: ${taskId}`);

              // ‰ªéÈü≥‰πêÁîüÊàêËÆ∞ÂΩï‰∏≠Ëé∑ÂèñÁî®Êà∑ID
              let userId = null;
              try {
                const musicGenQuery = await query(
                  'SELECT user_id FROM music_generations WHERE task_id = $1',
                  [taskId]
                );

                if (musicGenQuery.rows.length > 0) {
                  userId = musicGenQuery.rows[0].user_id;
                  console.log(`[CALLBACK-${callbackId}] Found userId for cover generation: ${userId}`);
                } else {
                  console.error(`[CALLBACK-${callbackId}] No music generation record found for task_id: ${taskId}`);
                }
              } catch (dbError) {
                console.error(`[CALLBACK-${callbackId}] Failed to query user_id for task_id ${taskId}:`, dbError);
              }

              const coverResponse = await fetch(`${process.env.CallBackURL}/api/generate-cover`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  musicTaskId: taskId,
                  userId: userId // Áõ¥Êé•‰º†ÈÄíÁî®Êà∑ID
                })
              });

              if (coverResponse.ok) {
                console.log(`[CALLBACK-${callbackId}] Cover generation started successfully for taskId: ${taskId}`);
              } else {
                const errorText = await coverResponse.text();
                console.error(`[CALLBACK-${callbackId}] Failed to start cover generation for music task ${taskId}:`, errorText);
              }
            } catch (coverError) {
              console.error(`[CALLBACK-${callbackId}] Error starting cover generation for music task ${taskId}:`, coverError);
            }
          });
        }
        // 4.1 textÂõûË∞ÉÔºöÂè™Â≠òÂÇ®Êï∞ÊçÆÂà∞Êï∞ÊçÆÂ∫ì
        console.log(`[CALLBACK-${callbackId}] Processing text callback database operations`);

        // ‰ΩøÁî®Á¨¨‰∏Ä‰∏™trackÁöÑÂÖÉÊï∞ÊçÆÊõ¥Êñ∞Êï∞ÊçÆÂ∫ìÔºàÈô§‰∫Üaudio_url‰ª•Â§ñÁöÑÊâÄÊúâÂÄºÔºâ
        const firstTrack = tracks[0];
        console.log(`[CALLBACK-${callbackId}] First track metadata:`, {
          id: firstTrack.id,
          title: firstTrack.title,
          hasPrompt: !!firstTrack.prompt,
          hasTags: !!firstTrack.tags
        });

        // 4.1.1 Êõ¥Êñ∞Èü≥‰πêÁîüÊàêËÆ∞ÂΩïÁöÑÂÖÉÊï∞ÊçÆ
        // style ‰ªÖ‰ΩøÁî®Êé•Âè£ËøîÂõûÁöÑ tagsÔºõÂ¶ÇÊûúÊ≤°Êúâ tags Âàô‰∏çÊõ¥Êñ∞ style Â≠óÊÆµ
        const styleFromTags = (firstTrack.tags && firstTrack.tags.trim() !== '') ? firstTrack.tags : undefined;

        // ÊèêÂèñÊ†áÈ¢ò - ‰ºòÂÖà‰ΩøÁî®track.titleÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÂ∞ùËØï‰ªéÊ≠åËØçÂÜÖÂÆπ‰∏≠ÊèêÂèñ
        let extractedTitle = firstTrack.title;
        if (!extractedTitle || extractedTitle.trim() === '') {
          // Â∞ùËØï‰ªéÊ≠åËØçÂÜÖÂÆπ‰∏≠ÊèêÂèñÊ†áÈ¢òÔºàÈÄöÂ∏∏Âú®Á¨¨‰∏ÄË°åÊàñËÄÖ[Title]Ê†áÁ≠æ‰∏≠Ôºâ
          const lyricsContent = firstTrack.prompt;
          if (lyricsContent) {
            // Êü•Êâæ [Title: xxx] Êàñ [title: xxx] Ê†ºÂºè
            const titleMatch = lyricsContent.match(/\[title:\s*([^\]]+)\]/i);
            if (titleMatch) {
              extractedTitle = titleMatch[1].trim();
            } else {
              // Êü•ÊâæÁ¨¨‰∏ÄË°åÈùûÁ©∫Ë°å‰Ωú‰∏∫Ê†áÈ¢òÔºàÂ¶ÇÊûú‰∏çÊòØverse/chorusÁ≠âÊ†áÁ≠æÔºâ
              const lines = lyricsContent.split('\n').map((line: string) => line.trim()).filter((line: string) => line);
              const firstLine = lines[0];
              if (firstLine && !firstLine.match(/^\[(verse|chorus|bridge|pre-?chorus|outro|intro)/i)) {
                extractedTitle = firstLine.replace(/^\[|\]$/g, ''); // ÁßªÈô§ÂèØËÉΩÁöÑÊñπÊã¨Âè∑
              }
            }
          }
        }

        // ÊûÑÂª∫Êõ¥Êñ∞ÂØπË±°ÔºåÂè™ÂåÖÂê´ÊúâÂÄºÁöÑÂ≠óÊÆµ
        const updateData: any = {
          status: 'text' // textÂõûË∞ÉÂ∑≤ÂÆåÊàêÔºåÊñáÊú¨‰ø°ÊÅØÂ∑≤ÁîüÊàê
        };

        // Âè™ÊúâÂΩìtitleÊúâÂÄºÊó∂ÊâçÊõ¥Êñ∞
        if (extractedTitle && extractedTitle.trim() !== '') {
          updateData.title = extractedTitle.trim();
        }
        // Âè™ÊúâÂΩìtagsÊúâÂÄºÊó∂ÊâçÊõ¥Êñ∞ style
        if (styleFromTags) {
          updateData.tags = styleFromTags;
        }

        try {
          console.log(`[CALLBACK-${callbackId}] Updating music generation record with extracted title: ${extractedTitle}`);
          await updateMusicGenerationByTaskId(taskId, updateData);
          console.log(`[CALLBACK-${callbackId}] Music generation record updated successfully`);
        } catch (dbError) {
          console.error(`[CALLBACK-${callbackId}] Failed to update music generation record with text data:`, dbError);
        }

        // 4.1.2 Â≠òÂÇ®Ê≠åËØçÂà∞music_lyricsË°®ÔºàÈü≥‰πêÁîüÊàê‰∏≠ÁöÑÊ≠åËØçÔºâ
        // Ê≠åËØçÂèØËÉΩÂú®Â§ö‰∏™Â≠óÊÆµ‰∏≠ÔºåÊåâ‰ºòÂÖàÁ∫ßÊ£ÄÊü•
        const lyricsContent = firstTrack.prompt;

        if (lyricsContent && lyricsContent.trim() !== '') {
          try {
            // Ëé∑Âèñmusic_generation_id
            const musicGenQuery = await query(
              'SELECT id FROM music_generations WHERE task_id = $1',
              [taskId]
            );

            if (musicGenQuery.rows.length > 0) {
              const musicGenerationId = musicGenQuery.rows[0].id;

              // ÂàõÂª∫Èü≥‰πêÊ≠åËØçËÆ∞ÂΩï - ‰ΩøÁî®ÊèêÂèñÁöÑÊ†áÈ¢ò
              const lyricsTitle = extractedTitle || 'Generated Lyrics';
              const lyricsRecord = await query(
                `INSERT INTO music_lyrics (music_generation_id, title, content)
                 VALUES ($1, $2, $3)
                 RETURNING *`,
                [musicGenerationId, lyricsTitle, lyricsContent]
              );
            } else {
            }

          } catch (lyricsError) {
            console.error('Failed to create music lyrics record:', lyricsError);
          }
        } else {
        }
        
        // 4.1.3 ÂàõÂª∫music_tracksËÆ∞ÂΩïÔºàÂç≥‰ΩøËøòÊ≤°Êúâaudio_urlÔºâ
        try {
          const musicGenQuery = await query(
            'SELECT id FROM music_generations WHERE task_id = $1',
            [taskId]
          );
          
          if (musicGenQuery.rows.length > 0) {
            const musicGenerationId = musicGenQuery.rows[0].id;
            // ÈªòËÆ§ËÆæÁΩÆ‰∏∫ÂÖ¨ÂºÄÔºåÁî®Êà∑ÂèØ‰ª•Âú®library‰∏≠ÊâãÂä®Ë∞ÉÊï¥
            const isPublished = true;
            
            // ‰∏∫ÊØè‰∏™trackÂàõÂª∫ËÆ∞ÂΩï
            for (let i = 0; i < tracks.length; i++) {
              const track = tracks[i];
              
              // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®ËØ•trackËÆ∞ÂΩïÔºåÈÅøÂÖçÈáçÂ§çÂàõÂª∫
              const existingTrackQuery = await query(
                'SELECT id FROM music_tracks WHERE music_generation_id = $1 AND side_letter = $2',
                [musicGenerationId, i === 0 ? 'A' : 'B']
              );
              
              if (existingTrackQuery.rows.length > 0) {
                // Êõ¥Êñ∞Áé∞ÊúâËÆ∞ÂΩï
                await query(
                  `UPDATE music_tracks SET 
                    suno_track_id = $1,
                    stream_audio_url = $2,
                    updated_at = NOW()
                  WHERE id = $3`,
                  [
                    track.id,
                    track.stream_audio_url,
                    existingTrackQuery.rows[0].id
                  ]
                );
              } else {
                // ÂàõÂª∫Êñ∞ËÆ∞ÂΩï
                const trackRecord = await query(
                  `INSERT INTO music_tracks (
                    music_generation_id,
                    suno_track_id,
                    side_letter,
                    stream_audio_url,
                    is_published
                  ) VALUES ($1, $2, $3, $4, $5)
                  RETURNING *`,
                  [
                    musicGenerationId,
                    track.id, // ‰ΩøÁî®track.id
                    i === 0 ? 'A' : 'B', // Á¨¨‰∏Ä‰∏™ÊòØAÈù¢ÔºåÁ¨¨‰∫å‰∏™ÊòØBÈù¢
                    track.stream_audio_url, // ‰øùÂ≠òÊµÅÂºèÈü≥È¢ëURLÂà∞stream_audio_urlÂ≠óÊÆµ
                    isPublished // Ê†πÊçÆÁî®Êà∑ÁöÑisPublishedÈÄâÊã©ËÆæÁΩÆ
                  ]
                );
              }
            }
          }
        } catch (tracksError) {
          console.error('Failed to create music_tracks records in text callback:', tracksError);
        }

        return; // Áõ¥Êé•ËøîÂõûÔºå‰∏çÂ§ÑÁêÜÂÖ∂‰ªñÈÄªËæë
        
      } else if (callbackType === 'first') {
        // 4.2 firstÂõûË∞ÉÔºöÂ∞Ü audio_url ÊåÅ‰πÖÂåñÂà∞ R2ÔºåÂπ∂Êõ¥Êñ∞Êï∞ÊçÆÂ∫ìÂØπÂ∫îË°®Â≠óÊÆµ
        console.log(`[CALLBACK-${callbackId}] Processing FIRST callback`);
        try {

          // ‰ªÖÂ§ÑÁêÜÂ∏¶Êúâ audio_url ÁöÑÊù°ÁõÆ
          const tracksWithAudio = tracks.filter((t: any) => t.audio_url && t.audio_url.trim() !== '');
          console.log(`[CALLBACK-${callbackId}] Tracks with audio: ${tracksWithAudio.length}/${tracks.length}`);

          if (tracksWithAudio.length === 0) {
            console.log(`[CALLBACK-${callbackId}] No tracks with audio found, returning early`);
            return;
          }
          // Êü•ËØ¢ userId
          let finalUserId: string = 'anonymous';
          try {
            const userQuery = await query(
              'SELECT user_id FROM music_generations WHERE task_id = $1',
              [taskId]
            );
            finalUserId = userQuery.rows[0]?.user_id || 'anonymous';
          } catch (dbErr) {
            console.error('Failed to query userId for first callback, fallback to anonymous:', dbErr);
          }

          // Êü•ËØ¢Â∑≤ÊúâÊ†áÈ¢ò‰Ωú‰∏∫ÂêéÂ§á
          let finalTitle = 'Untitled Song';
          try {
            const originalRecord = await query(
              'SELECT title FROM music_generations WHERE task_id = $1',
              [taskId]
            );
            const originalTitle = originalRecord.rows[0]?.title;
            finalTitle = originalTitle;
          } catch (titleErr) {
            console.error('Failed to resolve title for first callback, using default', titleErr);
          }

          // Ëé∑Âèñ music_generation_id
          const musicGenQuery = await query(
            'SELECT id FROM music_generations WHERE task_id = $1',
            [taskId]
          );
          const musicGenerationId = musicGenQuery.rows[0]?.id;
          if (!musicGenerationId) {
            console.error(`No music_generations record found for taskId: ${taskId} (first callback)`);
            return;
          }

          for (let i = 0; i < tracksWithAudio.length; i++) {
            const track = tracksWithAudio[i];
            const currentSideLetter: 'A' | 'B' = i === 0 ? 'A' : 'B';

            try {
              // ‰∏ãËΩΩÈü≥È¢ëÂπ∂‰∏ä‰º†Âà∞ R2
              const audioUrl = track.audio_url;
              const audioBuffer = await downloadFromUrl(audioUrl);

              const filename = `${finalTitle}_${i + 1}.mp3`;
              const audioR2Url = await uploadAudioFile(audioBuffer, taskId, filename, finalUserId || 'anonymous');

              // Êü•ÊâæÂπ∂Êõ¥Êñ∞ÂØπÂ∫îÁöÑ track ËÆ∞ÂΩïÔºàÊåâ side_letter ÂåπÈÖçÔºâ
              const existingTrackQuery = await query(
                'SELECT id FROM music_tracks WHERE music_generation_id = $1 AND side_letter = $2 ORDER BY created_at ASC LIMIT 1',
                [musicGenerationId, currentSideLetter]
              );

              if (existingTrackQuery.rows.length > 0) {
                const existingTrackId = existingTrackQuery.rows[0].id;
                await query(
                  `UPDATE music_tracks SET
                    audio_url = $1,
                    duration = $2,
                    updated_at = NOW()
                  WHERE id = $3`,
                  [
                    audioR2Url || null,
                    track.duration || null,
                    existingTrackId
                  ]
                );
              } else {
                console.error(`First callback: no existing track found for side ${currentSideLetter}, this should not happen`);
              }
            } catch (audioErr) {
              console.error(`Failed to persist audio for side ${currentSideLetter} in first callback:`, audioErr);
            }
          }
          
          // Êõ¥Êñ∞music_generationsÁä∂ÊÄÅ‰∏∫first (Â∏¶ÈáçËØïÊú∫Âà∂)
          await retryDatabaseOperation(async () => {
            await updateMusicGenerationByTaskId(taskId, {
              status: 'first'
            });
            console.log(`[CALLBACK-${callbackId}] Successfully updated status to 'first' for taskId: ${taskId}`);
          }, 3, callbackId, 'update status to first');
          
        } catch (err) {
          console.error('First callback processing error:', err);
        }
        return; // Â§ÑÁêÜÂÆåÊàêÔºåËøîÂõû

      } else if (callbackType === 'complete') {
        // 4.3 completeÂõûË∞ÉÔºöÂ§ÑÁêÜÊúÄÁªàÈü≥È¢ëÊñá‰ª∂‰∏ä‰º†Âà∞R2
        console.log(`[CALLBACK-${callbackId}] Processing COMPLETE callback`);


        // Ê£ÄÊü•Èü≥È¢ëÂáÜÂ§áÁä∂ÊÄÅ
        const audioReady = tracks.every((track: any) =>
          track.audio_url && track.audio_url.trim() !== ''
        );

        console.log(`[CALLBACK-${callbackId}] Audio readiness check for complete callback:`, {
          audioReady,
          trackCount: tracks.length,
          tracksWithAudio: tracks.filter((t: any) => t.audio_url && t.audio_url.trim() !== '').length
        });

        if (!audioReady) {
          console.log(`[CALLBACK-${callbackId}] Audio not ready for complete callback, returning early`);
          return;
        }
        // Ëé∑ÂèñÁî®Êà∑IDÂíåÊ†áÈ¢ò‰ø°ÊÅØ
        const musicGenQuery = await query(
          'SELECT id, user_id, title FROM music_generations WHERE task_id = $1',
          [taskId]
        );
        const musicGenerationId = musicGenQuery.rows[0]?.id;
        const finalUserId = musicGenQuery.rows[0]?.user_id || 'anonymous';
        const finalTitle = musicGenQuery.rows[0]?.title;
        
        if (!musicGenerationId) {
          console.error(`No music_generations record found for taskId: ${taskId} - this should not happen`);
          return;
        }
        
        // Ëé∑ÂèñÂ∑≤Â≠òÂú®ÁöÑtracksËÆ∞ÂΩïÔºåÊåâside_letterÊéíÂ∫è
        const existingTracksQuery = await query(
          'SELECT id, side_letter FROM music_tracks WHERE music_generation_id = $1 ORDER BY side_letter ASC',
          [musicGenerationId]
        );
        const existingTracks = existingTracksQuery.rows;
        
        if (existingTracks.length !== tracks.length) {
          console.error(`Mismatch: ${existingTracks.length} existing tracks vs ${tracks.length} callback tracks`);
          return;
        }
        
        // Â§ÑÁêÜÊØè‰∏™trackÁöÑÈü≥È¢ëÊñá‰ª∂
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          const existingTrack = existingTracks[i];
          const currentSideLetter = existingTrack.side_letter;
          
          try {
            // ‰∏ãËΩΩÈü≥È¢ëÊñá‰ª∂Âà∞R2
            let audioR2Url = null;
            // ‰ºòÂÖà‰ΩøÁî® source_audio_urlÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàô‰ΩøÁî® audio_url
            const audioUrl = track.source_audio_url || track.audio_url;

            if (audioUrl && audioUrl.trim() !== '') {
              const audioBuffer = await downloadFromUrl(audioUrl);
              const filename = `${finalTitle}_${i + 1}.mp3`;
              audioR2Url = await uploadAudioFile(audioBuffer, taskId, filename, finalUserId);
              
              // Âè™ÊúâÈü≥È¢ëÂ§ÑÁêÜÊàêÂäüÊâçÊõ¥Êñ∞Êï∞ÊçÆÂ∫ì
              await query(
                `UPDATE music_tracks SET 
                  audio_url = $1,
                  duration = $2,
                  updated_at = NOW()
                WHERE id = $3`,
                [
                  audioR2Url,
                  track.duration || null,
                  existingTrack.id
                ]
              );         
            } else {
            }
          } catch (error) {
            console.error(`Failed to process track ${i + 1}:`, error);
            // Èü≥È¢ëÂ§ÑÁêÜÂ§±Ë¥•Ôºå‰∏çÊõ¥Êñ∞Êï∞ÊçÆÂ∫ì
          }
        }
        
        // Êõ¥Êñ∞music_generationsÁä∂ÊÄÅ‰∏∫complete (Â∏¶ÈáçËØïÊú∫Âà∂)
        console.log(`[CALLBACK-${callbackId}] Updating music generation status to complete`);
        await retryDatabaseOperation(async () => {
          await updateMusicGenerationByTaskId(taskId, {
            status: 'complete'
          });
          console.log(`[CALLBACK-${callbackId}] Music generation status updated to complete successfully`);
        }, 5, callbackId, 'update status to complete'); // complete ÂõûË∞É‰ΩøÁî® 5 Ê¨°ÈáçËØï
        return;
      } else {
        console.log(`[CALLBACK-${callbackId}] Unknown or unhandled callback type: ${callbackType}`);
      }
      
    } else if (code !== 200) {
      // 5. Â§ÑÁêÜÂ§±Ë¥•ÁöÑÂõûË∞É
      console.log(`[CALLBACK-${callbackId}] Processing FAILED callback with code: ${code}, message: ${callbackData.msg}`);

      try {
        // Ëé∑ÂèñÈü≥‰πêÁîüÊàêËÆ∞ÂΩï‰ø°ÊÅØ
        const musicGenQuery = await query(
          'SELECT id, user_id, prompt FROM music_generations WHERE task_id = $1',
          [taskId]
        );

        if (musicGenQuery.rows.length > 0) {
          const musicGeneration = musicGenQuery.rows[0];
          const { msg } = callbackData;

          console.log(`[CALLBACK-${callbackId}] Found music generation record for failed callback:`, {
            generationId: musicGeneration.id,
            userId: musicGeneration.user_id,
            hasPrompt: !!musicGeneration.prompt
          });

          // Êõ¥Êñ∞Èü≥‰πêÁîüÊàêÁä∂ÊÄÅ‰∏∫ÈîôËØØ
          await updateMusicGenerationByTaskId(taskId, {
            status: 'error',
            title: musicGeneration.prompt || 'Unknown' // ‰ΩøÁî®Áî®Êà∑ËæìÂÖ•ÁöÑprompt‰Ωú‰∏∫Ê†áÈ¢ò
          });
          console.log(`[CALLBACK-${callbackId}] Updated music generation status to error`);

          // ÂàõÂª∫ÈîôËØØËÆ∞ÂΩï
          await createGenerationError(
            'music_generation',
            musicGeneration.id,
            msg || `Music generation failed with code ${code}`,
            `API_ERROR_${code}`
          );
          console.log(`[CALLBACK-${callbackId}] Created error record for failed generation`);

          // ÈÄÄËøòÁßØÂàÜ - Âõ†‰∏∫Áî®Êà∑Ê≤°ÊúâÂæóÂà∞‰ªª‰ΩïÈü≥‰πêÁªìÊûú
          try {
            // ‰ªé credit_transactions Ë°®‰∏≠Êü•ÊâæËØ• taskId ÁöÑÁßØÂàÜÊ∂àËÄóËÆ∞ÂΩï
            const creditTransactionResult = await query(
              `SELECT amount FROM credit_transactions 
               WHERE reference_id = $1 AND reference_type = 'music_generation' 
               AND transaction_type = 'spend' 
               ORDER BY created_at DESC LIMIT 1`,
              [taskId]
            );

            let creditCost = parseInt(process.env.BASIC_MODE_CREDITS || '7'); // ÈªòËÆ§ Basic Mode ÁöÑÁßØÂàÜÊ∂àËÄó
            if (creditTransactionResult.rows.length > 0) {
              creditCost = creditTransactionResult.rows[0].amount;
            } else {
              console.warn(`No credit transaction found for taskId ${taskId}, using default: ${creditCost} credits`);
            }

            const refundSuccess = await addUserCredits(
              musicGeneration.user_id,
              creditCost,
              `Music generation failed - refund (${msg || 'API error'})`,
              taskId,
              'music_generation_refund'
            );

            if (refundSuccess) {
              console.log(`[CALLBACK-${callbackId}] Credits refunded successfully: ${creditCost} credits to user ${musicGeneration.user_id}`);
            } else {
              console.error(`[CALLBACK-${callbackId}] Failed to refund credits for failed music generation: ${musicGeneration.id}`);
            }
          } catch (refundError) {
            console.error(`[CALLBACK-${callbackId}] Error refunding credits for failed music generation:`, refundError);
            // ‰∏çÊäõÂá∫ÈîôËØØÔºåÈÅøÂÖçÂΩ±ÂìçÈîôËØØËÆ∞ÂΩïÁöÑÂàõÂª∫
          }

        } else {
          console.error(`[CALLBACK-${callbackId}] No music_generations record found for failed taskId: ${taskId}`);
        }
      } catch (error) {
        console.error(`[CALLBACK-${callbackId}] Failed to process error callback:`, error);
      }
    } else {
      console.log(`[CALLBACK-${callbackId}] Unhandled callback condition - code: ${code}, hasData: ${!!data?.data}`);
    }

    // Log completion of async processing
    const asyncProcessingTime = Date.now() - asyncStartTime;
    console.log(`[CALLBACK-${callbackId}] Async processing completed in ${asyncProcessingTime}ms`);

  } catch (error) {
    console.error(`[CALLBACK-${callbackId}] Async callback processing failed:`, error);
    // Â∞ùËØïËé∑ÂèñtaskIdÁî®‰∫éÈîôËØØÈÄöÁü•
    try {
      const { data } = callbackData;
      const taskId = data?.task_id;
      if (taskId) {
        console.error(`[CALLBACK-${callbackId}] Error processing callback for taskId: ${taskId}`);
      }
    } catch (taskIdError) {
      console.error(`[CALLBACK-${callbackId}] Failed to extract taskId from error context:`, taskIdError);
    }
  }
}

// ÂÆöÊúüÊ∏ÖÁêÜÁºìÂ≠òÔºåÈò≤Ê≠¢ÂÜÖÂ≠òÊ≥ÑÊºè
setInterval(() => {
  if (processedTasks.size > 1000) {
    processedTasks.clear();
  }
}, 60 * 60 * 1000); // ÊØèÂ∞èÊó∂Ê∏ÖÁêÜ‰∏ÄÊ¨°
